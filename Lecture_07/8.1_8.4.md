# 8.1

## i
compileToFile (fromFile "ex11.c") "ex11.out";;

ex11.out:
24 19 1 5 25 15 1 15 1 15 100 14 0 99 2 15 100 14 0 99 2 15 100 14 0 99 2 15 100 14 0 99 2 13 0 2 1 0 1 12 15 -1 16 77 13 0 103 1 11 13 0 2 1 11 1 0 0 12 15 -1 13 0 2 1 13 0 2 1 11 0 1 1 12 15 -1 15 0 13 0 2 1 11 13 0 0 1 11 10 7 8 18 44 13 0 2 1 0 1 12 15 -1 16 148 13 0 204 1 11 13 0 2 1 11 1 13 0 305 1 11 13 0 2 1 11 1 0 0 12 12 15 -1 13 0 2 1 13 0 2 1 11 0 1 1 12 15 -1 15 0 13 0 2 1 11 0 2 13 0 0 1 11 3 10 7 8 18 103 13 0 1 1 13 0 2 1 0 1 12 12 15 -1 16 777 16 536 16 201 13 0 2 1 13 0 2 1 11 0 1 1 12 15 -1 13 0 2 1 11 13 0 0 1 11 10 7 8 17 284 13 0 103 1 11 13 0 2 1 11 1 11 18 256 13 0 204 1 11 13 0 2 1 11 13 0 1 1 11 2 13 0 0 1 11 1 1 11 16 258 0 1 18 280 13 0 305 1 11 13 0 2 1 11 13 0 1 1 11 1 1 11 16 282 0 1 16 286 0 0 18 186 13 0 2 1 11 13 0 0 1 11 10 7 8 17 408 13 0 406 1 11 13 0 1 1 11 1 13 0 2 1 11 12 15 -1 13 0 103 1 11 13 0 2 1 11 1 13 0 204 1 11 13 0 2 1 11 13 0 1 1 11 2 13 0 0 1 11 1 1 13 0 305 1 11 13 0 2 1 11 13 0 1 1 11 1 1 0 1 12 12 12 15 -1 13 0 1 1 13 0 1 1 11 0 1 1 12 15 -1 13 0 2 1 0 1 12 15 -1 15 0 16 534 13 0 1 1 13 0 1 1 11 0 1 2 12 15 -1 13 0 1 1 11 0 0 10 7 17 530 13 0 2 1 13 0 406 1 11 13 0 1 1 11 1 11 12 15 -1 13 0 103 1 11 13 0 2 1 11 1 13 0 204 1 11 13 0 2 1 11 13 0 1 1 11 2 13 0 0 1 11 1 1 13 0 305 1 11 13 0 2 1 11 13 0 1 1 11 1 1 0 0 12 12 12 15 -1 13 0 2 1 13 0 2 1 11 0 1 1 12 15 -1 15 0 16 532 15 0 15 0 15 0 13 0 1 1 11 13 0 0 1 11 10 7 8 17 562 13 0 1 1 11 0 0 6 8 16 564 0 0 18 184 13 0 1 1 11 13 0 0 1 11 10 7 17 773 15 1 13 0 407 1 0 1 12 15 -1 16 625 13 0 406 1 11 13 0 407 1 11 1 11 22 15 -1 13 0 407 1 13 0 407 1 11 0 1 1 12 15 -1 15 0 13 0 407 1 11 13 0 0 1 11 10 7 8 18 593 0 10 23 15 -1 13 0 1 1 13 0 1 1 11 0 1 2 12 15 -1 13 0 1 1 11 0 0 10 7 17 767 13 0 2 1 13 0 406 1 11 13 0 1 1 11 1 11 12 15 -1 13 0 103 1 11 13 0 2 1 11 1 13 0 204 1 11 13 0 2 1 11 13 0 1 1 11 2 13 0 0 1 11 1 1 13 0 305 1 11 13 0 2 1 11 13 0 1 1 11 1 1 0 0 12 12 12 15 -1 13 0 2 1 13 0 2 1 11 0 1 1 12 15 -1 15 0 16 769 15 0 15 -1 16 775 15 0 15 0 13 0 1 1 11 0 0 10 7 18 182 15 -406 21 0

## ii
> compileToFile (fromFile "ex3.c") "ex3.out";;
val it: Machine.instr list =
  [LDARGS; CALL (1, "L1"); STOP; Label "L1"; INCSP 1; GETBP; CSTI 1; ADD;
   CSTI 0; STI; INCSP -1; GOTO "L3"; Label "L2"; GETBP; CSTI 1; ADD; LDI;
   PRINTI; INCSP -1; GETBP; CSTI 1; ADD; GETBP; CSTI 1; ADD; LDI; CSTI 1; ADD;
   STI; INCSP -1; INCSP 0; Label "L3"; GETBP; CSTI 1; ADD; LDI; GETBP; CSTI 0;
   ADD; LDI; LT; IFNZRO "L2"; INCSP -1; RET 0]

| **Stack Machine Code**      | **Micro-C Code**   | **Notes**                                                             |
| --------------------------- | ------------------ | --------------------------------------------------------------------- |
| **LDARGS**                  |                    | Load command-line argument ($n$) onto stack. $n$ is at $\text{BP}+0$. |
| **CALL (1, "L1")**          | `main(n)`          | Call function `main` (Label L1) with 1 argument.                      |
| **STOP**                    |                    | Terminate execution.                                                  |
| **Label "L1"**              | `void main(int n)` | Start of `main` function (Label L1).      |
| **INCSP 1**                 | `int i;`           | Allocate space for local variable $i$ (at $\text{BP}+1$).             |
| **GETBP; CSTI 1; ADD**      |                    | Address of $i$ ($\text{BP}+1$).                                       |
| **CSTI 0**                  |                    | Value $0$.                                                            |
| **STI; INCSP -1**           | `i = 0;`           | Store $0$ into $i$.                                                   |
| **GOTO "L3"**               | `while (...)`      | Jump to condition check.                                              |
| **Label "L2"**              |                    | Start of loop body.                                                   |
| **GETBP; CSTI 1; ADD; LDI** |                    | Load value of $i$.                                                    |
| **PRINTI; INCSP -1**        | `print i;`         | Print the value of $i$.                                               |
| **GETBP; CSTI 1; ADD**      |                    | Address of $i$ ($\text{BP}+1$).                                       |
| **GETBP; CSTI 1; ADD; LDI** |                    | Load value of $i$.                                                    |
| **CSTI 1; ADD**             |                    | Compute $i + 1$.                                                      |
| **STI; INCSP -1**           | `i = i + 1;`       | Store $i+1$ back into $i$.                                            |
| **INCSP 0**                 |                    | No change to stack pointer.                                           |
| **Label "L3"**              | `while (i < n)`    | Start of condition check.                                             |
| **GETBP; CSTI 1; ADD; LDI** |                    | Load value of $i$.                                                    |
| **GETBP; CSTI 0; ADD; LDI** |                    | Load value of $n$ ($\text{BP}+0$).                                    |
| **LT**                      | `i < n`            | Compare $i$ and $n$ ($i < n$ is pushed, $1$ for true, $0$ for false). |
| **IFNZRO "L2"**             |                    | If $i < n$ (non-zero), jump to loop body (L2).                        |
| **INCSP -1**                |                    | Remove comparison result from stack.                                  |
| **RET 0**                   | `return;`          | Return from function (0 arguments/return value to clean up).          |

---

> compileToFile (fromFile "ex5.c") "ex5.out";;
val it: Machine.instr list =
  [LDARGS; CALL (1, "L1"); STOP; Label "L1"; INCSP 1; GETBP; CSTI 1; ADD;
   GETBP; CSTI 0; ADD; LDI; STI; INCSP -1; INCSP 1; GETBP; CSTI 0; ADD; LDI;
   GETBP; CSTI 2; ADD; CALL (2, "L2"); INCSP -1; GETBP; CSTI 2; ADD; LDI;
   PRINTI; INCSP -1; INCSP -1; GETBP; CSTI 1; ADD; LDI; PRINTI; INCSP -1;
   INCSP -1; RET 0; Label "L2"; GETBP; CSTI 1; ADD; LDI; GETBP; CSTI 0; ADD;
   LDI; GETBP; CSTI 0; ADD; LDI; MUL; STI; INCSP -1; INCSP 0; RET 1]

| **Stack Machine Code**           | **Micro-C Code**              | **Notes**                                                                                                                                                   |
| -------------------------------- | ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **LDARGS; CALL (1, "L1"); STOP** |                               | Setup and call `main`.                                                                                                                                      |
| **Label "L1"**                   | `void main(int n)`            | Start of `main`. Arg $n$ at $\text{BP}+0$.                                                                                                                  |
| **INCSP 1**                      | `int r;`                      | Allocate space for outer $r$ (at $\text{BP}+1$).                                                                                                            |
| **GETBP; CSTI 1; ADD**           |                               | Address of outer $r$.                                                                                                                                       |
| **GETBP; CSTI 0; ADD; LDI**      |                               | Load value of $n$ ($\text{BP}+0$).                                                                                                                          |
| **STI; INCSP -1**                | `r = n;`                      | Store $n$ into outer $r$.                                                                                                                                   |
| **INCSP 1**                      | `{ int r;`                    | **NESTED SCOPE START**: Allocate space for inner $r$ (at $\text{BP}+2$).                                                                                    |
| **GETBP; CSTI 0; ADD; LDI**      |                               | Load value of $n$ ($\text{BP}+0$) for the call argument.                                                                                                    |
| **GETBP; CSTI 2; ADD**           |                               | Address of inner $r$ ($\text{BP}+2$), passed as `&r` (the pointer argument).                                                                                |
| **CALL (2, "L2"); INCSP -1**     | `square(n, &r);`              | Call function `square` (L2) with 2 arguments: $n$ and $\&r$. Clean up 2 args from stack.                                                                    |
| **GETBP; CSTI 2; ADD; LDI**      |                               | Load value of inner $r$ (which was updated by `square` to $n^2$).                                                                                           |
| **PRINTI; INCSP -1**             | `print r;`                    | Print the value of the inner $r$ ($n^2$).                                                                                                                   |
| **INCSP -1**                     | `}`                           | **NESTED SCOPE END**: Deallocate space for inner $r$.                                                                                                       |
| **GETBP; CSTI 1; ADD; LDI**      |                               | Load value of outer $r$ (at $\text{BP}+1$).                                                                                                                 |
| **PRINTI; INCSP -1**             | `print r;`                    | Print the value of the outer $r$ ($n$).                                                                                                                     |
| **INCSP -1**                     |                               | Remove outer $r$ from stack.                                                                                                                                |
| **RET 0**                        | `return;`                     | Return from `main`.                                                                                                                                         |
| **Label "L2"**                   | `void square(int i, int *rp)` | Start of `square`. Arguments: $i$ at $\text{BP}+0$, $rp$ (the pointer) at $\text{BP}+1$.                                                                    |
| **GETBP; CSTI 1; ADD; LDI**      |                               | Load pointer address $rp$ (at $\text{BP}+1$), which is the address of inner $r$.                                                                            |
| **GETBP; CSTI 0; ADD; LDI**      |                               | Load value of $i$ ($\text{BP}+0$).                                                                                                                          |
| **GETBP; CSTI 0; ADD; LDI**      |                               | Load value of $i$ again.                                                                                                                                    |
| **MUL**                          | `i * i`                       | Compute $i \times i$.                                                                                                                                       |
| **STI; INCSP -1**                | `*rp = i * i;`                | Store $i \times i$ into the address pointed to by $rp$.                                                                                                     |
| **INCSP 0**                      |                               | No change to stack pointer.                                                                                                                                 |
| **RET 1**                        | `return;`                     | Return from function. |

As written in the notes above the nested body is showed by the creation and deletion of a variable located at BP + 2 within some operation before the function ends.

----

Trace the execution using java Machinetrace ex3.out 4,
### Setup

| **PC**   | **Instruction**                               | **Stack Contents** | **Micro-C Feature**                                                                                                            |
| -------- | --------------------------------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| **0**    | **LDARGS**                                    | `[ 4 ]`            | Load command-line argument $n=4$.                                                                                              |
| **1**    | **CALL 1 5**                                  | `[ 4 -999 4 ]`     | **Function Call:** Calls $\text{main}$ (starting at PC 5) with 1 argument. $n=4$ is at $\text{BP}-1$ (index 0).                |
| **5**    | **INCSP 1**                                   | `[ 4 -999 4 0 ]`   | **Variable Allocation (`int i;`):** Allocates space for local variable $i$ at $\text{BP}+2$. The stack content `0` is for $i$. |
| **7-14** | **GETBP; CSTI 1; ADD; CSTI 0; STI; INCSP -1** | `[ 4 -999 4 0 ]`   | **Assignment (`i=0;`)**                                                                                                        |
| **16**   | **GOTO 43**                                   | `[ 4 -999 4 0 ]`   | **Loop Start:** Jump to the condition check at PC 43.                                                                          |

### Loop Iteration ($i=0$)

| **PC**    | **Instruction**                                 | **Stack Contents** | **Stack Value → i or n**         | **Micro-C Feature**                          |
| --------- | ----------------------------------------------- | -------------------------------------- | -------------------------------- | -------------------------------------------- |
| **43-47** | **GETBP; CSTI 1; ADD; LDI**                     | `[ ... 0 ]`                            | $0$ $\rightarrow i$              | Load $i$'s value (0).                        |
| **48-52** | **GETBP; CSTI 0; ADD; LDI**                     | `[ ... 0 4 ]`                          | $4$ $\rightarrow n$              | Load $n$'s value (4).                        |
| **53**    | **LT**                                          | `[ ... 1 ]`                            | $0 < 4 \rightarrow 1$            | **Loop Condition:** $i < n$ is **TRUE (1)**. |
| **54**    | **IFNZRO 18**                                   | `[ ... ]`                              | $1 \ne 0 \rightarrow$ Jump to 18 | Jump to loop body.                           |
| **18-22** | **GETBP; CSTI 1; ADD; LDI**                     | `[ ... 0 ]`                            | $0 \rightarrow i$                | Load $i$'s value (0).                        |
| **23**    | **PRINTI**                                      | `[ ... 0 ]`                            | **Output: 0**                    | **`print i;`**                               |
| **24**    | **INCSP -1**                                    | `[ ... ]`                              |                                  | Clean up $i$'s value from stack.             |
| **26-38** | **GETBP; ...; LDI; CSTI 1; ADD; STI; INCSP -1** | `[ 4 -999 4 1 ]`                       | $0+1 \rightarrow 1$              | **Assignment (`i=i+1;`):** $i$ becomes $1$.  |
| **41**    | **INCSP 0**                                     | `[ 4 -999 4 1 ]`                       |                                  |                                              |
| **43**    | **GOTO 43**                                     | `[ 4 -999 4 1 ]`                       |                                  | Jump back to condition check.                |

### Loop Iterations ($i=1, 2, 3$)

The steps for $i=1, 2, 3$ are identical in structure to $i=0$:
- **$i=1$ Iteration:**
    - PC 43-53: $1 < 4 \rightarrow$ **TRUE (1)**.
    - PC 54: Jumps to 18.
    - PC 18-23: **`PRINTI`** outputs **1**.
    - PC 26-38: $i=1+1 \rightarrow i$ becomes **2**.
    - PC 43: Jumps to 43.
- **$i=2$ Iteration:**
    - PC 43-53: $2 < 4 \rightarrow$ **TRUE (1)**.
    - PC 54: Jumps to 18.
    - PC 18-23: **`PRINTI`** outputs **2**.
    - PC 26-38: $i=2+1 \rightarrow i$ becomes **3**.
    - PC 43: Jumps to 43.
- **$i=3$ Iteration:**
    - PC 43-53: $3 < 4 \rightarrow$ **TRUE (1)**.
    - PC 54: Jumps to 18.
    - PC 18-23: **`PRINTI`** outputs **3**.
    - PC 26-38: $i=3+1 \rightarrow i$ becomes **4**.
    - PC 43: Jumps to 43.

### Termination

| **PC**    | **Instruction**             | **Stack Contents** | **Stack Value → i or n**     | **Micro-C Feature**                           |
| --------- | --------------------------- | -------------------------------------- | ---------------------------- | --------------------------------------------- |
| **43-47** | **GETBP; CSTI 1; ADD; LDI** | `[ ... 4 ]`                            | $4 \rightarrow i$            | Load $i$'s value (4).                         |
| **48-52** | **GETBP; CSTI 0; ADD; LDI** | `[ ... 4 4 ]`                          | $4 \rightarrow n$            | Load $n$'s value (4).                         |
| **53**    | **LT**                      | `[ ... 0 ]`                            | $4 < 4 \rightarrow 0$        | **Loop Condition:** $i < n$ is **FALSE (0)**. |
| **54**    | **IFNZRO 18**               | `[ ... 0 ]`                            | $0 = 0 \rightarrow$ Continue | Loop terminates.                              |
| **56**    | **INCSP -1**                | `[ 4 -999 4 4 ]`                       |                              | Clean up comparison result (0).               |
| **58**    | **RET 0**                   | `[ 4 ]`                                |                              | **Function Return**                           |
| **4**     | **STOP**                    | `[ 4 ]`                                |                              | **Program Exit.**                             |



# 8.4
## i
void main adds the LDARGS and CALL calls. But it doesn't have a real impact on the performance. The same is true for the labels; they're just nicer GOTOs.

It has to store the i value.
The core issue is that it has to interface with the variable i instead of being able to just perform the operations directly.

It needs to first load the value, then update it, then store, and finally compare again. This compared to `prog1` that can just update and compare.

## ii
On a fundamental level, loops are constructed by skipping to the end and then using conditionals to check if they should loop.
All of the other conditionals are seemingly to handle the body of the code.
When looking at it, there is a lot of the smaller labels that seem redundant, but we figured it is likely for making the process generic. So, while it makes little to no sense for some of them in `ex13.c`'s code, they might be incredibly important in more complex code bodies.

Sometimes it also does some weird stuff like saying "EQ;NOT;IFNZRO *a*;" instead of just "EQ;IFZRO *a*".